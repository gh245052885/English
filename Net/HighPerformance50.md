# 高效编程 改进C#代码的50个行之前效的办法

## 第二章 NET资源管理

#### 2.12 推荐使用成员初始化器而不是赋值语句

当你添加一个新的成员变量的时间，直接在其声明的位置初始化即可，

这些初始化会被添加到编译器自动生成的默认构造函数中。

#### 2.13 正确地初始化静态成员变量
#### 2.14 尽量减少重复的初使化逻辑
#### 2.15 使用Using和Try/finally清理资源
说明：使用了非托管系统的类型必须显式使用IDisposable接口的Dispose（）来释放。实现了IDisposable接口。

类型在终结器中调用Dispose（），
保证你在忘记的时间仍能正常释放资源。只是内存停留更长的时间。
#### 2.16 避免创建非必要的对象

#### 2.18 区分值类型和引用类型
值类型 用来存放数据 引用类型用来定义行为
#### 2.19 保证0为值类型的有效态
类Emnum必须将0设定为一个有效选择。
#### 2.20 保证值类型的常量性和原子性
代码更加编写和维护

## 第三章 使用表达设计
#### 3.2
#### 3.2
#### 3.23 理解接口方法和虚方法的区别
#### 3.24 用委托实现回调
委托用于将方法作为参数传递给其他方法。 事件处理程序就是通过委托调用的方法。
你可以创建一个自定义方法，当发生特定事件时，某个类（如 Windows 控件）就可以调用你的方法。
在方法重载的上下文中，方法的签名不包括返回值。 
但在委托的上下文中，签名包括返回值。 换句话说，方法和委托必须具有相同的返回类型
委托允许我们在运行时配置目标并通知多个客户对象 常用的委托形式
* Predicatt<T>  返回布尔类型
* Func<> 一系列的参数，返回单一的结果
* Action<> 入参不限，但无返回值
Linq的所有功能都依赖于委托，
Net中的委托都是多播委托。
#### 3.25 用事件模式实现通知
事件是实现广播类型行为信息的标准方式。
#### 2.2
#### 2.2
#### 2.2

## 第6章 杂项
#### 6.45 尽量减少装箱和拆箱
值类型是数据的容器，不支持多态。
* 装箱：把一个值类型放在一个未确定类型的引用对象中。装箱把值转成引用类型，将分配于堆上。

存放的是值类型的副本。取数据时返回的是值类型的另一个副本。

* 拆箱：从箱中获取出其中值类型的副本。
#### 6.46 为应用程序创建专门的异常类
#### 6.47 使用强异常安全保证
#### 6.48 尽量使用安全的代码
#### 6.49 实现与CLS兼容的程序集
